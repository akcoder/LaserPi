<# //The majority of this code was adapted from T4MVC by David Ebbo #>
<#@ template language="C#" debug="true" hostSpecific="true" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.Interop.8.0" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>
<#@ assembly name="VSLangProj" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Linq.Expressions" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="Microsoft.VisualStudio.Shell.Interop" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="EnvDTE80" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ include file="ViewModelLocator.settings.t4" #>
<# PrepareDataToRender(this); #>
// <auto-generated />
using System;
using System.Diagnostics;
using System.CodeDom.Compiler;
<# if (UseIoc) {
	if (!string.IsNullOrWhiteSpace(IocLocatorNamespace))
		WriteLine("using {0};", IocLocatorNamespace);
	if (!string.IsNullOrWhiteSpace(IocNamespace))
		WriteLine("using {0};", IocNamespace);
} #>
using GalaViewModelBase = GalaSoft.MvvmLight.ViewModelBase;
using GalaSoft.MvvmLight.Ioc;
using Microsoft.Practices.ServiceLocation;


namespace <#= Models.First().Namespace #> {
	[<#= GeneratedCode #>, DebuggerNonUserCode]
	public class ViewModelLocator {
  		public ViewModelLocator() {
			<#= IocSetup #>;
<#
			PushIndent("\t\t\t");
			foreach(var viewModel in Models) {
				if (UseIoc & IocRegister.Length > 0) {
					WriteLine(string.Format(IocRegister, viewModel.ClassName));
				}
				if (CacheViewModelInstances) {
					WriteLine(string.Format("Create{0}();", viewModel.ClassName));
				}
			}
			ClearIndent();
#>
		}

	  	public static void Cleanup() {
<#
			foreach(var viewModel in Models) {
				Write(string.Format("\t\t\tClear{0}();\r\n", viewModel.ClassName));
			}
			ClearIndent();
#>
		}

<#	foreach(var viewModel in Models) { #>
		#region <#= viewModel.ClassName #>

<# if (CacheViewModelInstances || !UseIoc) { #>
		private static <#= viewModel.ClassName #> <#= viewModel.FieldName #>;

        /// <summary>
        /// Gets the RecordViewModel property.
        /// </summary>
        public static <#= viewModel.ClassName #> <#= viewModel.ClassName #>Static {
            get {
<# if (CacheViewModelInstances) { #>
                if (<#= viewModel.FieldName #> == null) {
                    Create<#= viewModel.ClassName #>();
                }
<# } else { #>
				<#= viewModel.FieldName #> = new <#= viewModel.ClassName #>();
<# } #>
                return <#= viewModel.FieldName #>;
            }
        }
<# } #>
        /// <summary>
        /// Gets the <#= viewModel.ClassName #> property.
        /// </summary>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1822:MarkMembersAsStatic", Justification = "This non-static member is needed for data binding purposes.")]
        public <#= viewModel.ClassName #> <#= viewModel.PropertyName #> {
            get
            {
<# if (!CacheViewModelInstances && UseIoc) { #>
				return <#= string.Format(IocLocator, viewModel.ClassName) #>;
<# } else { #>
                return <#= viewModel.ClassName #>Static;
<# } #>
            }
        }

        /// <summary>
        /// Provides a deterministic way to delete the <#= viewModel.ClassName #> property.
        /// </summary>
        public static void Clear<#= viewModel.ClassName #>() {
<# if (CacheViewModelInstances || !UseIoc) { #>
            if (<#= viewModel.FieldName #> != null) {
                <#= viewModel.FieldName #>.Cleanup();
                <#= viewModel.FieldName #> = null;
            }
<# } else { #>
			<#= string.Format(IocLocator, viewModel.ClassName) #>.Cleanup();
<# } #>
        }

<# if (CacheViewModelInstances) { #>
        /// <summary>
        /// Provides a deterministic way to create the <#= viewModel.ClassName #> property.
        /// </summary>
        public static void Create<#= viewModel.ClassName #>() {
            if (<#= viewModel.FieldName #> == null) {
			    if (GalaViewModelBase.IsInDesignModeStatic)
                	<#= viewModel.FieldName #> = new <#= viewModel.ClassName #>();
				else
<# if (UseIoc) { #>
					<#= viewModel.FieldName #> = <#= string.Format(IocLocator, viewModel.ClassName) #>;
<# } else { #>
	                <#= viewModel.FieldName #> = new <#= viewModel.ClassName #>();
<# } #>
            }
        }
<# } #>
		#endregion

<# } #>
	}
}
<#+
static DTE Dte;
static List<ViewModelInfo> Models;
static Project Project;
static TextTransformation TT;
static string T4FileName;
static string T4Folder;
static string GeneratedCode = @"GeneratedCode(""T4ViewModelLocator"", ""1.0"")";
static Microsoft.CSharp.CSharpCodeProvider codeProvider = new Microsoft.CSharp.CSharpCodeProvider();


List<ViewModelInfo> LoadViewModels() {

	var result = new List<ViewModelInfo>();
	var viewModelItem = Project.ProjectItems.Item(ViewModelFolder);
	for(var i = 1; i <= viewModelItem.ProjectItems.Count; ++i) {
		var modelItems = ProcessViewModelItem(viewModelItem.ProjectItems.Item(i));

		result.AddRange(modelItems);
	}
	
	return result;
}

  // Insert any template procedures here
Project GetProjectContainingT4File(DTE dte) {

    // Find the .tt file's ProjectItem
    ProjectItem projectItem = dte.Solution.FindProjectItem(Host.TemplateFile);

    // If the .tt file is not opened, open it
    if (projectItem.Document == null)
        projectItem.Open(Constants.vsViewKindCode);

    if (AlwaysKeepTemplateDirty) {
        // Mark the .tt file as unsaved. This way it will be saved and update itself next time the
        // project is built. Basically, it keeps marking itself as unsaved to make the next build work.
        // Note: this is certainly hacky, but is the best I could come up with so far.
        projectItem.Document.Saved = false;
    }

    return projectItem.ContainingProject;
}

void PrepareDataToRender(TextTransformation tt) {
    TT = tt;
    T4FileName = Path.GetFileName(Host.TemplateFile);
    T4Folder = Path.GetDirectoryName(Host.TemplateFile);
    //Areas = new HashSet<AreaInfo>();

    // Get the DTE service from the host
    var serviceProvider = Host as IServiceProvider;
    if (serviceProvider != null) {
        Dte = serviceProvider.GetService(typeof(SDTE)) as DTE;
    }

    // Fail if we couldn't get the DTE. This can happen when trying to run in TextTransform.exe
    if (Dte == null) {
        throw new Exception("T4MVC can only execute through the Visual Studio host");
    }

    Project = GetProjectContainingT4File(Dte);

	
	Models = LoadViewModels();
    if (Project == null) {
        Error("Could not find the VS Project containing the T4 file.");
        return;
    }
}

List<ViewModelInfo> ProcessViewModelItem(ProjectItem projectItem) {

	var result = new List<ViewModelInfo>();
    
	if (projectItem.FileCodeModel != null) {
        foreach (var type in projectItem.FileCodeModel.CodeElements.OfType<CodeClass2>()) {
            var types = ProcessViewModelType(type);
			if (types != null)
				result.Add(types);
        }
        // Process all the elements that are namespaces
        foreach (var ns in projectItem.FileCodeModel.CodeElements.OfType<CodeNamespace>()) {
            foreach (var type in ns.Members.OfType<CodeClass2>()) {
	            var types = ProcessViewModelType(type);
				if (types != null)
					result.Add(types);
            }
        }
    }
	
	return result;
}

class ViewModelInfo {
    public string ViewPath {
        get {
            return String.Format("~/{0}/{1}/", ViewsFolder, ClassName);
        }
    }

    public bool HasExplicitConstructor { get; set; }
    public bool HasExplicitDefaultConstructor { get; set; }
    public bool HasDefaultConstructor { get { return !HasExplicitConstructor || HasExplicitDefaultConstructor; } }
    public bool IsAbstract { get; set; }

    public bool GeneratedCodeIsUpToDate { get; set; }

    public string ClassName { get; set; }
	
	public string FieldName
	{
		get { return "_" + ClassName[0].ToString().ToLowerInvariant() + ClassName.Substring(1); }
	}
	
	public string PropertyName
	{
		get { return ClassName.Substring(0, ClassName.IndexOf("ViewModel")); }
	}

    public string Namespace { get; set; }

    public string FullClassName {
        get {
            return MakeClassName(Namespace, ClassName);
        }
    }

    public override string ToString() {
        return ClassName;
    }

    public override bool Equals(object obj) {
        return obj != null && FullClassName == ((ViewModelInfo)obj).FullClassName;
    }

    public override int GetHashCode() {
        return FullClassName.GetHashCode();
    }
}

static string MakeClassName(string ns, string classname) {
    return String.IsNullOrEmpty(ns) ? classname :
        String.IsNullOrEmpty(classname) ? ns : ns + "." + codeProvider.CreateEscapedIdentifier(classname);
}

ViewModelInfo ProcessViewModelType(CodeClass2 type) {
	if (type.Name == "ViewModelLocator")
		return null;

	if (type.IsAbstract)
		return null;

    // Don't process generic classes (their concrete derived classes will be processed)
    if (type.IsGeneric)
        return null;

    // Collect misc info about the controller class and add it to the collection
    var viewModelInfo = new ViewModelInfo {
        Namespace = type.Namespace != null ? type.Namespace.Name : String.Empty,
        ClassName = type.Name
    };

    // Either process new ControllerInfo or integrate results into existing object for partially defined controllers
    viewModelInfo.HasExplicitConstructor |= HasExplicitConstructor(type);
    viewModelInfo.HasExplicitDefaultConstructor |= HasExplicitDefaultConstructor(type);

	return viewModelInfo;
}


// Check if the class has any explicit constructor
static bool HasExplicitConstructor(CodeClass2 codeClass) {
    return codeClass.Members.OfType<CodeFunction2>().Any(
        f => f.FunctionKind == vsCMFunction.vsCMFunctionConstructor);
}

// Check if the class has a default (i.e. no params) constructor
static bool HasExplicitDefaultConstructor(CodeClass2 codeClass) {
    return codeClass.Members.OfType<CodeFunction2>().Any(
        f => f.FunctionKind == vsCMFunction.vsCMFunctionConstructor && f.Parameters.Count == 0);
}

#>